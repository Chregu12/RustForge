//! Session management for saving and loading Tinker sessions

use anyhow::{anyhow, Result};
use chrono::Utc;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};

/// A Tinker session script
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionScript {
    /// Session name
    pub name: String,
    /// Creation timestamp
    pub created_at: String,
    /// Commands in the session
    pub commands: Vec<String>,
    /// Session metadata
    pub metadata: Option<serde_json::Value>,
}

impl SessionScript {
    /// Create a new session script
    pub fn new(name: String, commands: Vec<String>) -> Self {
        Self {
            name,
            created_at: Utc::now().to_rfc3339(),
            commands,
            metadata: None,
        }
    }

    /// Add metadata to session
    pub fn with_metadata(mut self, metadata: serde_json::Value) -> Self {
        self.metadata = Some(metadata);
        self
    }

    /// Convert to executable script
    pub fn to_script(&self) -> String {
        let mut script = String::new();
        script.push_str(&format!("// Tinker Session: {}\n", self.name));
        script.push_str(&format!("// Created: {}\n", self.created_at));
        script.push_str("// Auto-generated by Foundry Tinker\n\n");

        for cmd in &self.commands {
            script.push_str(cmd);
            if !cmd.ends_with('\n') {
                script.push('\n');
            }
        }

        script
    }
}

/// Session manager for Tinker
pub struct SessionManager {
    sessions_dir: PathBuf,
}

impl SessionManager {
    /// Create a new session manager
    pub fn new(sessions_dir: PathBuf) -> Self {
        Self { sessions_dir }
    }

    /// Ensure sessions directory exists
    fn ensure_dir(&self) -> Result<()> {
        if !self.sessions_dir.exists() {
            fs::create_dir_all(&self.sessions_dir)?;
        }
        Ok(())
    }

    /// Save a session
    pub fn save(&self, session: &SessionScript) -> Result<PathBuf> {
        self.ensure_dir()?;

        let filename = format!("{}.json", sanitize_filename(&session.name));
        let path = self.sessions_dir.join(filename);

        let json = serde_json::to_string_pretty(session)?;
        fs::write(&path, json)?;

        Ok(path)
    }

    /// Load a session by name
    pub fn load(&self, name: &str) -> Result<SessionScript> {
        let filename = format!("{}.json", sanitize_filename(name));
        let path = self.sessions_dir.join(filename);

        if !path.exists() {
            return Err(anyhow!("Session '{}' not found", name));
        }

        let json = fs::read_to_string(&path)?;
        let session: SessionScript = serde_json::from_str(&json)?;

        Ok(session)
    }

    /// List all saved sessions
    pub fn list(&self) -> Result<Vec<String>> {
        if !self.sessions_dir.exists() {
            return Ok(Vec::new());
        }

        let mut sessions = Vec::new();

        for entry in fs::read_dir(&self.sessions_dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) == Some("json") {
                if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                    sessions.push(stem.to_string());
                }
            }
        }

        sessions.sort();
        Ok(sessions)
    }

    /// Delete a session
    pub fn delete(&self, name: &str) -> Result<()> {
        let filename = format!("{}.json", sanitize_filename(name));
        let path = self.sessions_dir.join(filename);

        if !path.exists() {
            return Err(anyhow!("Session '{}' not found", name));
        }

        fs::remove_file(&path)?;
        Ok(())
    }

    /// Get sessions directory
    pub fn sessions_dir(&self) -> &Path {
        &self.sessions_dir
    }
}

/// Sanitize filename to remove invalid characters
fn sanitize_filename(name: &str) -> String {
    name.chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '-' || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_session_script_new() {
        let session = SessionScript::new(
            "test_session".to_string(),
            vec!["helpers".to_string(), "models".to_string()],
        );

        assert_eq!(session.name, "test_session");
        assert_eq!(session.commands.len(), 2);
    }

    #[test]
    fn test_session_to_script() {
        let session = SessionScript::new(
            "test".to_string(),
            vec!["let x = 42;".to_string(), "println!(x);".to_string()],
        );

        let script = session.to_script();
        assert!(script.contains("Tinker Session: test"));
        assert!(script.contains("let x = 42;"));
        assert!(script.contains("println!(x);"));
    }

    #[test]
    fn test_session_manager_save_load() {
        let temp_dir = TempDir::new().unwrap();
        let manager = SessionManager::new(temp_dir.path().to_path_buf());

        let session = SessionScript::new(
            "test_session".to_string(),
            vec!["command1".to_string(), "command2".to_string()],
        );

        let path = manager.save(&session).unwrap();
        assert!(path.exists());

        let loaded = manager.load("test_session").unwrap();
        assert_eq!(loaded.name, session.name);
        assert_eq!(loaded.commands, session.commands);
    }

    #[test]
    fn test_session_manager_list() {
        let temp_dir = TempDir::new().unwrap();
        let manager = SessionManager::new(temp_dir.path().to_path_buf());

        let session1 = SessionScript::new("session1".to_string(), vec![]);
        let session2 = SessionScript::new("session2".to_string(), vec![]);

        manager.save(&session1).unwrap();
        manager.save(&session2).unwrap();

        let sessions = manager.list().unwrap();
        assert_eq!(sessions.len(), 2);
        assert!(sessions.contains(&"session1".to_string()));
        assert!(sessions.contains(&"session2".to_string()));
    }

    #[test]
    fn test_session_manager_delete() {
        let temp_dir = TempDir::new().unwrap();
        let manager = SessionManager::new(temp_dir.path().to_path_buf());

        let session = SessionScript::new("test".to_string(), vec![]);
        manager.save(&session).unwrap();

        manager.delete("test").unwrap();
        assert!(manager.load("test").is_err());
    }

    #[test]
    fn test_sanitize_filename() {
        assert_eq!(sanitize_filename("hello world"), "hello_world");
        assert_eq!(sanitize_filename("test@session"), "test_session");
        assert_eq!(sanitize_filename("valid-name_123"), "valid-name_123");
    }
}
